# Memoria

Facciamo un'estensione del linguaggio per supportare la memoria. Ma vogliamo dargli una connotazione funzionale.

Molti linguaggi funzionali hanno il costrutto `let`. Si legge come "sia". Possiamo chiamarla posizione.

```
let x=3 in:
    x+1
```

Introduciamo delle espressioni chiamate block expression del tipo: `{ var x=3; var y=5*x; f(x,y)}`.
Questa è un'espressione, quindi potremmo fare:`{ var x=3; var y=5*x; f(x,y)} * 5`.

> Una block expression è una sequenza di definizioni di variabili, con la loro espressione, seguita da un'espressione.

L'obiettivo è scrivere qualcosa del tipo:

```
def fibonacci(n)
    n < 2 ? 1 :
        {
            var f2 = fibonacci(n-2);
            var f1 = fibonacci(n-1);
            f1 + f2
        };
```

Da dove cominciamo? Dal parser: dobbiamo fissare la grammatica.

Lexical scope in quasi tutti i linguaggi. Permette shadowing delle variabili e utilizza le locali prima delle globali.

Devo poter fare una cosa del tipo:

```
def fibonacci(n)
    n < 2 ? 1 :
        {
            var n = n-1;
            var f2 = fibonacci(n-1);
            var f1 = fibonacci(n);
            f1 + f2
        };
```
Ma per ora non lo facciamo.

## Grammatica

Facciamo finta di avere due binding, consideriamo le derivazioni in avanti.

$$
vardefs \to vardefs; binding \to binding; binding
$$

in un parser bottom-up, la prima riduzione è $binding; binding \to vardefs; binding$; allora per capire dove creare il
vettore devo considerare proprio quella riduzione. Metto la creazione nel `binding` da solo.

La riduzione che chiude la ricorsione delle riduzioni vardefs è in realtà la prima che viene fatta.
