# Valutazione delle espressioni

> Lavoriamo di cacciavite e chiave inglese

La prima modifica al codice è aggiungere l'istruzione condizionale (l'if). Così il linguaggio diventa Turing-completo.

## PrototypeAST

Ha un metodo `noemit`, ed è l'unico cambio al parser. Nello scanner non cambia niente.

## Driver

All'interno c'è una symbol table, implementata come un map (quindi tabella associativa chiave-valore) inizialmente vuota.

In root_ast ci scrive il parser, quando effettua l'ultima riduzione.

Infine abbiamo la funzione `codegen`, che rimpiazza visit, ed è la chiamata top che va a chiamare i codegen specializzati
nelle varie sottoclassi (per generare i costrutti adeguati). Il metodo è virtual.

## LLVM

Abbiamo tre classi importanti, di cui ci serve un singolo oggetto per ognuno. Se scrivessimo programmi su più file avremmo
bisogno di più `Module`. Un file contiene dichiarazioni external e dichiarazioni di funzioni.

LLVM context è una classe opaca che mantiene tutte le strutture dati importanti nella generazione del codice.

I metodi della classe Builder generano internamente rappresentazioni di tutte le istruzioni.

## Codegen

`codegen` del driver va a chiamare `codegen` del nodo radice.

### SeqAST

Tutte le codegen restituiscono un Value, ovvero un'istruzione o equivalentemente un SSA dove è stato lasciato il valore
prodotto da quel codice. `f` è un SSA.

Scendo l'albero di sinistra (first), genero il codice e questo lascerà il codice in un registro SSA chiamato f.

Per la coda della sequenza, chiamo codegen sulla continuation. Posso evitare di memorizzare il valore per la
continuation.

### Operatore binario

Valuto il LHS e il RHS ricorsivamente. Se entrambi sono diversi da nullptr allora andiamo a creare il giusto operatore
corrispondente. Opzionalmente passiamo alla funzione CreateFAdd il nome di un registro SSA in cui mettere il risultato.

I nomi vengono automaticamente incrementati.

### Number

Non corrisponde a un'istruzione, ma è una costante. La codegen viene chiamata sempre nel contesto di un'altra espressione.

Le costanti **devono essere uniche** e devono essere mantenute dal contesto. Vengono rese unicamente nel programma finale.

Il metodo `ConstantFP::get` restituisce le costanti come _singleton_.

```c++
//  Esempio per ottenere una costante 3
ConstantFP::get(*context, APFloat(Val));
```

passo per APFloat perché è la rappresentazione di LLVM delle costanti numeriche. Faccio i singoletti su quella
rappresentazione.

### Variabili

Nel processo di generazione del codice usiamo una tabella associativa nomi-valori. Qui non c'è il valore della variabile
al contrario di un interprete, perché sarà noto solo a tempo di esecuzione.

Nella tabella abbiamo nomi associati a istruzioni che allocherebbe uno spazio necessario per tenere il valore della
variabile. L'istruzione alloca la variabile in memoria, restituisce in un SSA il puntatore alla memoria.

La funzione responsabile si chiama `CreateEntryBlockAlloca` che restituisce un'AllocaInst, ovvero il tipo di un'istruzione
di allocazione. Prende in input una funzione (rappresentazione interna che ha tutte le funzioni del suo codice, prima di
emetterla) e un nome.

Definisce un IRBuilder temporaneo (per non interagire col builder principale che tiene traccia di dove il codice è stato
scritto).

Una funzione è fatta di basic blocks (blocchi di codice che terminano con un salto). Il builder temporaneo comincia a
scrivere nell'entry block della funzione. Il builder ha un metodo `CreateAlloca` che scrive codice intermedio per allocare
memoria.

Il context tiene soprattutto i tipi e le costanti, infatti posso recuperarla con `Type::getDoubleTy(*context)`. Il VarName
è il nome che verrà dato al registro SSA. Se un valore ha il `%` davanti è un puntatore.

### Variable expression

Il valore di una variabile sta in una zona di memoria, dobbiamo prenderlo e portarlo in un registro SSA. Utilizzarlo e
mettere il risultato in un'altra locale.

Il codegen per il valore di una variabile è:

- accesso per chiave alla tabella `drv.NamedValues[Name]`, che mi dà l'SSA (o istruzione) che alloca memoria e restituisce
il puntatore;

- se `!A`, ovvero se la variabile non è definita e non l'ho trovata nella symbol table, sollevo un errore. Questo è un
errore **semantico**;

- altrimenti chiamiamo il builder (globale) su `CreateLoad`, quindi creo un'istruzione load che prende il valore dal
puntatore e la mette in un registro SSA. Alla funzione passo il nome del registro SSA su cui ho messo il puntatore.

La corrispondenza tra SSA e istruzioni è **biunivoca**.

```llvm
%2 = load double, ptr %1, align 8
```

viene creato dalla chiama a CreateLoad commentata prima. Il codice per "usare una variabile" si traduce in questo.

### Call expression

Siamo alla chiamata di funzione, quindi per essere chiamata deve essere stata definita precedentemente oppure come
extern.

Le funzioni stanno nei moduli, quindi per recuperare una funzione vado nel modulo attuale e chiamo il metodo
`getFunction` a cui passo Callee, attributo nel nodo, che contiene il nome della funzione chiamata.

Nella semplicità notiamo che supporta già la ricorsione, ma non le forward declaration.

#### Controlli semantici

Teoricamente potremmo metterli nella sintassi se usassimo una grammatica dipendente dal contesto.

Se la variabile `CalleeF` è un nullptr allora la funzione non è stata definita.

Supponiamo che la funzione sia già stata definita, ma la dobbiamo ancora vedere.

Controlliamo i parametri: il numero lo abbiamo nell'AST e si chiama Args (vettore di argomenti). La funzione `CalleeF`
ha un metodo `arg_size()` che mi ritorna il numero di parametri che ha. I due valori devono coincidere, un mismatch
danno un errore semantico.

Gli argomenti sono delle espressioni e quindi a loro volta includere delle altre chiamate di funzione. Ricorsivamente
bisogna costruire un vettore con gli argomenti valutati (Value *). Prendiamo il valore in registri SSA.

Per ogni argomento (double), metto nel vettore il codice generato corrispondente a quell'argomento.

Alla fine chiamiamo il builder su `CreateCall` con il nome della funzione da chiamare, gli argomenti e il nome del
registro SSA di destinazione.

## Function prototype

Cosa manca? Gestire le dichiarazioni di funzione. Guardiamo prima le external, perché le definizioni aggiungono anche un
body.

Un prototipo viene salvato in PrototypeAST, che ha un attributo (tra gli altri) emitcode normalmente impostato su `true`.
Il metodo `noemit` mette la variabile `emitcode` su false.

Nel nodo abbiamo anche il nome della funzione, numero e nome dei parametri. Un nome di funzione può avvenire dopo `def`
oppure `extern`, la differenza è che nel primo caso ci aspettiamo anche il body.

Prima di tutto dobbiamo definire il tipo della funzione: tipo del risultato più numero e tipo dei parametri.

Creo un vettore con i tipi degli argomenti. Noi manipoliamo solo dei double quindi avremo un vettore di tipi double.
Adesso ho un FunctionType che viene preso dal contesto, se non esiste lo genero.

Adesso possiamo definire una funzione LLVM (oggetto di tipo `Function`). Le nostre funzioni hanno tutti linkage esterno,
tipo appena creato (tipo degli argomenti + tipo di ritorno), e la mettiamo all'interno di module come visibilità.

```c++
unsigned Idx = 0;
for (auto &Arg : F->args())
Arg.setName(Args[Idx++]);
```

Per dare un nome ai parametri, chiamiamo `setName` sull'attributo `Arg` dell'oggetto PrototypeAST.

Chi chiama noemit? Il parser quando effettua la riduzione `definition`. Il codice del prototipo non viene emesso se è
nel contesto di una funzione. Se lo togliamo il prototipo viene definito due volte.

Mentre la riduzione `external` non va a chiamare `noemit`. Siamo in una dichiarazione.

Se non faccio `noemit` mi viene prodotto un IR:

```llvm
declare double @f(double, double)

define double @f(double %x, double %y)
...body
```

altrimenti quando vado a valutare il body, riemettro un define. La colpa è di LLVM e lo vediamo nella parte successiva.
